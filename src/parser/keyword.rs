use std::fmt;

#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]
pub enum Keyword {
    And,
    As,
    Asc,
    Begin,
    Bool,
    Boolean,
    By,
    Char,
    Commit,
    Create,
    Cross,
    Default,
    Delete,
    Desc,
    Double,
    Drop,
    Explain,
    False,
    Float,
    From,
    Group,
    Having,
    Index,
    Infinity,
    Inner,
    Insert,
    Int,
    Integer,
    Into,
    Is,
    Join,
    Key,
    Left,
    Like,
    Limit,
    NaN,
    Not,
    Null,
    Of,
    Offset,
    On,
    Only,
    Or,
    Order,
    Outer,
    Primary,
    Read,
    References,
    Right,
    Rollback,
    Select,
    Set,
    String,
    System,
    Table,
    Text,
    Time,
    Transaction,
    True,
    Unique,
    Update,
    Values,
    VarChar,
    Where,
    Write,
    UserIdent,
}

impl fmt::Display for Keyword {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "keyword: {}",
            match self {
                Self::And => "AND",
                Self::As => "As",
                Self::Asc => "Asc",
                Self::Begin => "Begin",
                Self::Bool => "Bool",
                Self::Boolean => "Boolean",
                Self::By => "By",
                Self::Char => "Char",
                Self::Commit => "Commit",
                Self::Create => "Create",
                Self::Cross => "Cross",
                Self::Default => "Default",
                Self::Delete => "Delete",
                Self::Desc => "Desc",
                Self::Double => "Double",
                Self::Drop => "Drop",
                Self::Explain => "Explain",
                Self::False => "False",
                Self::Float => "Float",
                Self::From => "From",
                Self::Group => "Group",
                Self::Having => "Having",
                Self::Index => "Index",
                Self::Infinity => "Infinity",
                Self::Inner => "Inner",
                Self::Insert => "Insert",
                Self::Int => "Int",
                Self::Integer => "Integer",
                Self::Into => "Into",
                Self::Is => "Is",
                Self::Join => "Join",
                Self::Key => "Key",
                Self::Left => "Left",
                Self::Like => "Like",
                Self::Limit => "Limit",
                Self::NaN => "Nan",
                Self::Not => "Not",
                Self::Null => "Null",
                Self::Of => "Of",
                Self::Offset => "Offset",
                Self::On => "On",
                Self::Only => "Only",
                Self::Or => "Or",
                Self::Order => "Order",
                Self::Outer => "Outer",
                Self::Primary => "Primary",
                Self::Read => "Read",
                Self::References => "References",
                Self::Right => "Right",
                Self::Rollback => "Rollback",
                Self::Select => "Select",
                Self::Set => "Set",
                Self::String => "String",
                Self::System => "System",
                Self::Table => "Table",
                Self::Text => "Text",
                Self::Time => "Time",
                Self::Transaction => "Transaction",
                Self::True => "True",
                Self::Unique => "Unique",
                Self::Update => "Update",
                Self::Values => "Values",
                Self::VarChar => "Varchar",
                Self::Where => "Where",
                Self::Write => "Write",
                Self::UserIdent => "UserIdent",
            }
        )
    }
}

pub fn find_keyword(keyword_str: &String) -> Keyword {
    // 转化为大写
    let upper_keyword_str = keyword_str.to_uppercase();

    match upper_keyword_str.as_str() {
        "AND" => Keyword::And,
        "AS" => Keyword::As,
        "ASC" => Keyword::Asc,
        "BEGIN" => Keyword::Begin,
        "BOOL" => Keyword::Bool,
        "BOOLEAN" => Keyword::Boolean,
        "BY" => Keyword::By,
        "CHAR" => Keyword::Char,
        "COMMIT" => Keyword::Commit,
        "CREATE" => Keyword::Create,
        "CROSS" => Keyword::Cross,
        "DEFAULT" => Keyword::Default,
        "DELETE" => Keyword::Delete,
        "DESC" => Keyword::Desc,
        "DOUBLE" => Keyword::Double,
        "DROP" => Keyword::Drop,
        "EXPLAIN" => Keyword::Explain,
        "FALSE" => Keyword::False,
        "FLOAT" => Keyword::Float,
        "FROM" => Keyword::From,
        "GROUP" => Keyword::Group,
        "HAVING" => Keyword::Having,
        "INDEX" => Keyword::Index,
        "INFINITY" => Keyword::Infinity,
        "INNER" => Keyword::Inner,
        "INTEGER" => Keyword::Integer,
        "INSERT" => Keyword::Insert,
        "INT" => Keyword::Int,
        "INTO" => Keyword::Into,
        "IS" => Keyword::Is,
        "JOIN" => Keyword::Join,
        "KEY" => Keyword::Key,
        "LEFT" => Keyword::Left,
        "LIKE" => Keyword::Like,
        "LIMIT" => Keyword::Limit,
        "NAN" => Keyword::NaN,
        "NOT" => Keyword::Not,
        "NULL" => Keyword::Null,
        "OF" => Keyword::Of,
        "OFFSET" => Keyword::Offset,
        "ON" => Keyword::On,
        "ONLY" => Keyword::Only,
        "OR" => Keyword::Or,
        "ORDER" => Keyword::Order,
        "OUTER" => Keyword::Outer,
        "PRIMARY" => Keyword::Primary,
        "READ" => Keyword::Read,
        "REFERENCES" => Keyword::References,
        "RIGHT" => Keyword::Right,
        "ROLLBACK" => Keyword::Rollback,
        "SELECT" => Keyword::Select,
        "STRING" => Keyword::String,
        "SET" => Keyword::Set,
        "SYSTEM" => Keyword::System,
        "TABLE" => Keyword::Table,
        "TEXT" => Keyword::Text,
        "TIME" => Keyword::Time,
        "TRANSACTION" => Keyword::Transaction,
        "TRUE" => Keyword::True,
        "UNIQUE" => Keyword::Unique,
        "UPDATE" => Keyword::Update,
        "VALUES" => Keyword::Values,
        "VARCHAR" => Keyword::VarChar,
        "WHERE" => Keyword::Where,
        "WRITE" => Keyword::Write,
        _ => Keyword::UserIdent,
    }
}
